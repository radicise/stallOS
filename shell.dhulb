#define SHELLMEM_SIZE 128
#define SHELLMAP_COUNT 16
#define PATH_MAX 512
#import <obj/ObjStr.dhulb>
#import <obj/Map.dhulb>
#utilise "shell.s" docscan
#import <io/bufferIO.dhulb>
#import "defs.dhulb"
#import <sys.dhulb>
#import <ioutil.dhulb>
#import <stall/stack.dhulb>
int hexdump(*InputStream in) {
	u8 g;
	int r;
	u32 t;
	u8 c;
	0x20 as u8 -> t$ as *u8[2];
	0 as u8 -> t$ as *u8[3];
	:hexdump__loop;
	r = in.read@(g$, 1, in);
	if (r <= 0) {
		println("");
		return r;
	}
	c = g & 0x0f;
	if (c > 9) {
		c = c + 0x37;
	}
	else {
		c = c + 0x30;
	}
	c -> t$ as *u8[1];
	c = g >> 4;
	if (c > 9) {
		c = c + 0x37;
	}
	else {
		c = c + 0x30;
	}
	c -> t$;
	print(t$);
	/*print_uint(g to uint);*/
	goto hexdump__loop;
}
int parse_args(*u8 entry, *int argCount, int maxArgCount, **u8 args) {
	/* args has (maxArgCount + 1) entries reserved */
	/* maxArgCount >= 0 */
	int mo = 0;
	*u8 e2;
	:parse_args__loop4;
	if (entry@ == 0x20) {
		entry = entry + 1;
		goto parse_args__loop4;
	}
	if (entry@ == 0x00) {
		0 -> argCount;
		null as *u8 -> args;
		return 0;
	}
	e2 = entry;
	:parse_args__loop;
	if (mo == maxArgCount) {
		mo -> argCount;
		null as *u8 -> args[mo];
		return 0;
	}
	:parse_args__loop2;
	if (entry@ == 0x00) {
		e2 -> args[mo];
		mo = mo + 1;
		mo -> argCount;
		null as *u8 -> args[mo];
		return 0;
	}
	if (entry@ == 0x20) {
		0x00 as u8 -> entry;
		e2 -> args[mo];
		mo = mo + 1;
		:parse_args__loop3;
		entry = entry + 1;
		if (entry@ == 0x20) {
			goto parse_args__loop3;
		}
		if (entry@ == 0x00) {
			mo -> argCount;
			null as *u8 -> args[mo];
			return 0;
		}
		e2 = entry;
		goto parse_args__loop;
	}
	entry = entry + 1;
	goto parse_args__loop2;
}
int shell_trace(int argc, **u8 argv) {
	/*
	BufferInputStream bis;
	bufIn_init(sp() - 200, 512, bis$);
	hexdump(bis$);
	bis$.close@(bis$);
	*/
	StackTracer st;
	0 -> st$.count;
	return trace(st$);
}
int systest(int argc, **u8 argv) {
	:systest__loop;
	if (argc == 0) {
		return 0;
	}
	println(argv@);
	argv = argv[1];
	argc = argc - 1;
	goto systest__loop;
}
int shelld(*u8 curdir, *u8 smem, *MapEntry uninit_map) {
	Map programs;
	Map_init(uninit_map, $$SHELLMAP_COUNT$$, programs$);
	ObjStr shobj;
	ObjStr_init("sh", shobj$);
	programs$.add@(shobj$, shell, programs$);
	ObjStr testobj;
	ObjStr_init("test", testobj$);
	programs$.add@(testobj$, systest, programs$);
	ObjStr traceobj;
	ObjStr_init("trace", traceobj$);
	programs$.add@(traceobj$, shell_trace, programs$);
	int lastRetVal = 0;
	u8 ran;
	:shell__loop;
	print(curdir);
	print("# ");
	readLine($$STDIN_FILENO$$, $$STDOUT_FILENO$$, smem, $$SHELLMEM_SIZE$$);
	println(smem);
	shell_do(smem, ran$, programs$, lastRetVal$);
	/*
	if (strcmp("exit", smem) == 0) {
		return lastRetVal;
	}
	if (bcmp("exit ", smem, 5) == 0) {
		smem = smem + 5;
		:shelld__exitnum_loop1;
		if (smem@ == 0x00) {
			return lastRetVal;
		}
		if (smem@ == 0x20) {
			smem = smem + 1;
			goto shelld__exitnum_loop1;
		}
		u8 neg = 0;
		if (smem@ == 0x2d) {
			smem = smem + 1;
			if ((smem@ < 0x30) | (smem@ > 0x39)) {
				return 0;
			}
			neg = 1;
		}
		else ((smem@ < 0x30) | (smem@ > 0x39)) {
			return lastRetVal;
		}
		int rv = 0;
		:shelld__exitnum_loop2;
		rv = rv * 10 + (smem@ - 0x30);
		smem = smem + 1;
		if ((smem@ < 0x30) | (smem@ > 0x39)) {
			if (neg) {
				return 0 - rv;
			}
			return rv;
		}
		goto shelld__exitnum_loop2;
	}
	else {
		ran = 0;
	}
	*/
	if (ran == 0x01) {
		print("returned: ");
		print_uint(lastRetVal to uint);
		println("");
	}
	else (ran == 0x02) {
		println("command not found");
	}
	else (ran == 0x03) {
		println("Argument list too long");
	}
	goto shell__loop;
}
/%
root:
.byte 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00
%/
/*imply SLTFS16Part root;*/

