#if OPERAND_BITS != 16
	#error "Unsupported operand size"
#endif
#if CALL_BITS != 16
	#error "Unsupported call size"
#endif 
#import <pc/io.dhulb>
#import <dos/api_bindings.dhulb>
#import "errno.dhulb"
#utilise "sys.s" docscan
VGAMode3Out console;
int bread(int fd) {
	if (fd != $$STDIN_FILENO$$) {
		return (0 - 1);
	}
	return dos_console_input();
}
int bwrite(int fd, u8 val) {
	if (fd != $$STDOUT_FILENO$$) {
		return (0 - 1);
	}
	dos_console_output(val);
	return 1;
}
int write(int fd, addr a, uint len) {
	if (fd != $$STDOUT_FILENO$$) {
		return (0 - 1);
	}
	if (len == 0) {
		return 0;
	}
	fd = a + len;
	:write__loop;
	if (fd == a) {
		return len;
	}
	dos_console_output((a as *u8)@);
	a = a + 1;
	goto write__loop;
}
int read(int fd, addr a, uint len) {
	if (fd != $$STDIN_FILENO$$) {
		return (0 - 1);
	}
	fd = a + len;
	:read__loop;
	if (fd == a) {
		return len;
	}
	dos_console_input() -> (a as *u8);
	a = a + 1;
	goto read__loop;
}
int close(int fd) {
	return 0 - $$EIO$$;
}
uint rand_last;
int rand(uint max) {
	:rand__loop;
	rand_last = rand_last + 21845 + 21846;
	if (rand_last <= max) {
		return rand_last;
	}
	goto rand__loop;
}
int lseek(int fd, u32 off, int mode) {
	return (0 - 1);
}
#import <io/streams.dhulb>
struct FileOutputStream extends OutputStream {
	int fd;
}
int fdOut_write(addr src, uint len, *FileOutputStream it) {
	return write(it.fd@, src, len);
}
int fdOut_close(*FileOutputStream it) {
	return close(it.fd@);
}
int fdOut_init(int fd, *FileOutputStream it) {
	fd -> it.fd;
	fdOut_write -> it.write;
	fdOut_close -> it.close;
	return 0;
}
#define NULL 0
