#import "errno.dhulb"
struct Fileblock {
	u8 used,
	u16 perms,
	u16 refCount,
	u32 length;
}
struct Datablock {
	u8 used,
	u16 blockLen,
	u16 prev,
	u16 next,
	u16 pad0,
	u16 pad1,
	u16 pad2,
	u16 pad3,
	u8 data;
}
struct Dirsect {
	u8 name,
	u8 pad0,
	u8 pad1,
	u8 pad2,
	u8 pad3,
	u8 pad4,
	u8 pad5,
	u8 pad6,
	u8 pad7,
	u8 pad8,
	u8 pad9,
	u8 pad10,
	u8 pad11,
	u8 pad12,
	u8 pad13,
	u8 pad14,
	u8 pad15,
	u8 pad16,
	u8 pad17,
	u8 pad18,
	u8 pad19,
	u8 pad20,
	u8 pad21,
	u8 pad22,
	u8 pad23,
	u8 pad24,
	u8 pad25,
	u8 pad26,
	u8 pad27,
	u8 pad28,
	u8 pad29,
	u8 pad30,
	u8 type,
	u16 bNum;
}
struct Dirblock {
	u8 used,
	u16 perms,
	u16 numChildren,
	u16 prev,
	u16 next,
	u16 pad0,
	u16 pad1,
	u16 pad2,
	Dirsect entries;
}
struct FSDef {
	u8 used,
	u8 blockLen,
	u16 sizeBlocks;
}
struct SLTFS16FDData {
	u32 pos,
	u16 fileNum,
	u16 dataNum;
}
struct STLFS16Part {
	u8 blockLen,
	u16 sizeBlocks,
	s16 fd,
	u32 offset,
	u8 maxNodeDepth,
	u16 pad0;	
}
struct STLFS16Path {
	STLFS16Part part,
	Dirsect node;
}/*One more Dirsect after maxNodeDepth Dirsect, for null-termination using bNum = 0*/

/*
imply s16 split(a16*u8, u8);/*replaces given character with a null and moves each part to the left when the character is at the beginning and when multiple of the character are next to each other and returns the amount of items*/
/*
imply s16 getPath(a16*u8, a16*STLFS16Path, a16*Dirblock);
/&
getPath:
jmp getPathAny
&/
int getRelPath(*u8 form, *STLFS16Path res, *Dirblock place) {
	int g = split(form, 0x2f as u8);
	*Dirsect nval = res.node;
	:getRelPath__loop;
	if (nval.bNum == 0) {
		nval = nval - 48;
		if (g == 0) {
			if ((res - nval) == 32) {
				return 1;
			}
			return nval.type;
		}
		g = g - 1;
		:getRelPath__loop2;
		if (((form@) == (0x2e as u8)) & ((form[1]@) == (0 as u8))) {
			form = form + strlen(form) + 1;
			goto getRelPath__loop2;
		}
		if (((form@) == (0x2e as u8)) & ((form[1]@) == (0x2e as u8)) & ((form[2]@) == (0 as u8))) {
			form = form + strlen(form) + 1;
			if ((res - nval) != 32) {
				nval.bNum = 0;
				nval = nval - 48;
			}
			goto getRelPath__loop2;
		}
		if ((res - nval) != 32) {
			if ((nval.type@ != 1) & (nval.type@ != 3)) {
				return (0 - $$ENOTDIR$$);
			}
			if (nval.type == 1) {
				lseek(res.part.fd@, res.part.offset@ + ((512 as u32) * (res.part.blockLen@ as u32) * (nval.bNum@ as u32)), $$SEEK_SET$$); 
				read(res.part.fd@, place, res.part.blockLen@ * 512);
			}
			else {
				*Dirblock b;
				*STLFS16Path c;
				*u8 a;
				res.part.blockLen@;
				/&
					xorb %ah,%ah
					xorw %dx,%dx
					movw $0x0200,%bx
					mulw %bx
					subw %ax,%sp
					subw $0x0100,%sp
				&/
				a = a$ - 256;
				b = a - (res.part.blockLen@ * 512);
				file_read(nval.bNum@, a, 256);
				64 + (res.part.maxNodeDepth@ * 48);
				/&
					subw %ax,%sp
				&/
				{
					getPath(a, c, b);
					uint g = res.part.maxNodeDepth;
					*Dirsect l = c.node;
					if (l.bNum != 0) {
						:getRelPath__loop3;
						if (l.bNum != 0) {
							l = l + 48;
							goto getRelPath__loop3;
						}
						l = l - 48;
					}
					else {
					1 -> l.bNum;
					lseek(res.part.fd@, res.part.offset@ + ((512 as u32) * (res.part.blockLen@ as u32) * (l.bNum@ as u32)), $$SEEK_SET$$);
					read(res.part.fd@, place, res.part.blockLen@ * 512);
			
				}
				64 + (res.part.maxNodeDepth@ * 48);
				/&
					addw %ax,%sp
				&/
				res.part.blockLen@;
				/&
					xorb %ah,%ah
					xorw %dx,%dx
					movw $0x0200,%bx
					mulw %bx
					addw %ax,%sp
					addw $0x0100,%sp
				&/
			}
			(nval + 96).bNum = 0;
			nval = nval + 48;
			
		}
		else {
			lseek(res.part.fd@, res.part.offset@ + ((512 as u32) * (res.part.blockLen@ as u32) * (1 as u32)), $$SEEK_SET$$); 
			read(res.part.fd@, place, res.part.blockLen@ * 512);
		}
		getChild(place, form, nval, res.part.blockLen, res.part.offset, res.part.fd);
		form = form + strlen(form) + 1;
	}
	nval = nval + 48;
	goto getRelPath__loop;
}
int getPathAny(*u8 form, *STLFS16Path res, *Dirblock place) {
	if (form@ == (0x2f as u8)) {
		0 -> res.node.bNum;
	}
	return getRelPath(form, res, place);
}
int getChild(*Dirblock dir, *u8 name, *Dirsect res, uint blockSize, uint offset, int fd) {/*Contents at dir are invalidated*//*
	uint g = dir.numChildren@;
	uint j = 0;
	*Dirsect t = dir.entries;
	:getChild__loop;
	if (j == g) {
		return (0 - $$ENOENT$$);
	}
	j = j + 1;
	if (strcmp(name, t.name) == 0) {
		memcpy(res, t, 48);
		return t.type;
	}
	t = t + 48;
	if ((j % numPerBlock) == 0){
		lseek(fd, (offset as u32) + ((512 as u32) * (blockSize as u32) * (dir.next as u32)), $$SEEK_SET$$); 
		read(fd, dir, blockSize * 512);
		t = dir.entries;
	}
	goto getChild__loop;
}
*/
